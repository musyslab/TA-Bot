from collections import defaultdict
import os
from src.repositories.database import db
from .models import StudentGrades, OHVisits, StudentSuggestions, StudentUnlocks, SubmissionChargeRedeptions, SubmissionCharges, Submissions, Projects, Users, SubmissionManualErrors
from sqlalchemy import desc, and_
from typing import Dict, List, Tuple
from datetime import datetime, timedelta

class SubmissionRepository():

    def get_submission_by_user_id(self, user_id: int) -> Submissions:
        """Returns the latest submission made by a user with the given user_id.

        Args:
            user_id (int): The ID of the user whose submission is to be retrieved.

        Returns:
            Submissions: The latest submission made by the user with the given user_id.
        """
        submission = Submissions.query.filter(Submissions.User == user_id).order_by(desc("Time")).first()
        return submission

    def get_submission_by_user_and_projectid(self, user_id:int, project_id: int)-> Submissions:
        """Returns the latest submission made by a user for a given project.

        Args:
            user_id (int): The ID of the user.
            project_id (int): The ID of the project.

        Returns:
            Submissions: The latest submission object made by the user for the given project.
        """
        submission = Submissions.query.filter(and_(Submissions.Project == project_id, Submissions.User == user_id)).order_by(desc("Time")).first()
        return submission

    def get_submission_by_submission_id(self, submission_id: int) -> Submissions:
        """Retrieves a submission by its ID.

        Args:
            submission_id (int): The ID of the submission to retrieve.

        Returns:
            Submissions: The submission object with the specified ID.
        """
        submission = Submissions.query.filter(Submissions.Id == submission_id).order_by(desc("Time")).first()
        return submission

    def get_code_path_by_submission_id(self, submission_id: int) -> str:
        """Returns the file path of the code file associated with a submission.

        Args:
            submission_id (int): The ID of the submission.

        Returns:
            str: The file path of the code file associated with the submission.
        """
        submission = self.get_submission_by_submission_id(submission_id)
        return submission.CodeFilepath

    def read_code_file(self, code_path) -> str:
        """Returns the contents of the code file associated with a given submission.

        Args:
            submission_id (int): The ID of the submission.

        Returns:
            str: The contents of the code file associated with the submission.
        """
        student_file = ""
        #TODO: Make More Robust for Multiple Files, this simply grabs the first file in the directory
        if os.path.isdir(code_path):
            for filename in os.listdir(code_path):
                with open(filename, "r") as f:
                    student_file = f.read()
                break
        else:
            with open(code_path, "r") as f:
                student_file = f.read()
        return student_file
        
    def read_output_file(self, output_path) -> str:
        """Returns the contents of the output file associated with a given submission.

        Args:
            submission_id (int): The ID of the submission.

        Returns:
            str: The contents of the output file associated with the submission.
        """
        student_output_file = ""
        with open(output_path, "r") as f:
            student_output_file = f.read()
        return student_output_file
    
    def create_submission(self, user_id: int, output: str, codepath: str, time: str, project_id: int, status: bool, errorcount: int, testcase_results: str):
        """Creates a new submission record in the database.

        Args:
            user_id (int): The ID of the user who submitted the code.
            output (str): The filepath of the output file generated by the code.
            codepath (str): The filepath of the code file submitted.
            time (str): The time at which the submission was made.
            project_id (int): The ID of the project for which the code was submitted.
            status (bool): Whether the submission passed or failed.
            score (int): The score awarded to the submission.

        Returns:
            int: The ID of the newly created submission record.
        """
        submission = Submissions(
            OutputFilepath=output,
            CodeFilepath=codepath,
            Time=time,
            User=user_id,
            Project=project_id,
            IsPassing=status,
            TestCaseResults=str(testcase_results),
        )        
        db.session.add(submission)
        db.session.commit()
        created_id = submission.Id  # Assuming the auto-incremented ID field is named "ID"
        return created_id

    def get_total_submission_for_all_projects(self) -> Dict[int, int]:
        """
        Returns a dictionary containing the total number of unique submissions for each project.

        Returns:
        - A dictionary where the keys are project IDs and the values are the total number of unique submissions for that project.
        """
        thisdic={}
        project_ids = Projects.query.with_entities(Projects.Id).all()
        for proj in project_ids:
            count = Submissions.query.with_entities(Submissions.User).filter(Submissions.Project == proj[0]).distinct().count()
            thisdic[proj[0]]=count
        return thisdic

    def get_most_recent_submission_by_project(self, project_id: int, user_ids: List[int]) -> Dict[int, Submissions]:
        """
        Returns a dictionary containing the most recent submission for each user in a given project.

        Args:
            project_id (int): The ID of the project to search for submissions.
            user_ids (List[int]): A list of user IDs to search for submissions.

        Returns:
            Dict[int, Submissions]: A dictionary where the keys are user IDs and the values are the most recent submission for each user.
        """
        holder = Submissions.query.filter(and_(Submissions.Project == project_id, Submissions.User.in_(user_ids))).order_by(desc(Submissions.Time)).all()
        bucket={}
        for obj in holder:
            if obj.User in bucket:
                if bucket[obj.User].Time < obj.Time:
                    bucket[obj.User] = obj
                else:
                    pass
            else:
                bucket[obj.User] = obj
        return bucket

    def get_project_by_submission_id(self, submission_id: int) -> int:
        """Returns the project ID associated with a given submission ID.

        Args:
            submission_id (int): The ID of the submission.

        Returns:
            int: The ID of the project associated with the submission.
        """
        submission = Submissions.query.filter(Submissions.Id == submission_id).first()
        return submission.Project

    def submission_view_verification(self, user_id, submission_id) -> bool:
        submission = Submissions.query.filter(and_(Submissions.Id==submission_id,Submissions.User==user_id)).first()
        return submission is not None
        
    def unlock_check(self, user_id,project_id) -> bool:
        unlocked_info = StudentUnlocks.query.filter(and_(StudentUnlocks.ProjectId==project_id,StudentUnlocks.UserId==user_id)).first()
        current_day=datetime.today().strftime('%A')
        #TODO: Make this not hardcoded for 2.0
        return (current_day == "Wednesday" and unlocked_info != None)
        
    def submission_counter(self, project_id: int, user_ids: List[int]) -> bool:
        submissions = Submissions.query.filter(and_(Submissions.Project == project_id, Submissions.User.in_(user_ids))).all()
        submission_counter_dict={}
        for sub in submissions:
            if sub.User in submission_counter_dict:
                submission_counter_dict[sub.User] = submission_counter_dict[sub.User] +1
            else:
                submission_counter_dict[sub.User] = 1
        return submission_counter_dict

    def Submit_Student_OH_question(self, question, user_id, project_id):
        dt_string = datetime.now().strftime("%Y/%m/%d %H:%M:%S")
        student_question = OHVisits(StudentQuestionscol=question, StudentId=user_id, dismissed=0, ruling=-1, TimeSubmitted=dt_string, projectId=project_id)
        db.session.add(student_question)
        db.session.commit()
        return str(student_question.Sqid)
    def Submit_OH_ruling(self, question_id, ruling):
        question = OHVisits.query.filter(OHVisits.Sqid == question_id).first()
        question.ruling = int(ruling)
        if(int(ruling) == 0):
            question.dismissed = int(1)
        else:
            question.TimeAccepted = datetime.now().strftime("%Y/%m/%d %H:%M:%S")
        db.session.commit()
        return "ok"
    def Submit_OH_dismiss(self, question_id):
        question = OHVisits.query.filter(OHVisits.Sqid == question_id).first()
        #Get classId based on the projectID
        project = Projects.query.filter(Projects.Id == question.projectId).first()
        classId = project.ClassId
        question.dismissed = int(1)
        question.TimeCompleted = datetime.now().strftime("%Y/%m/%d %H:%M:%S")
        db.session.commit()
        return [question.StudentId, classId]
    def Get_all_OH_questions(self, include_dismissed: bool = False):
        """
        include_dismissed=False (default): only active (dismissed == 0)
        include_dismissed=True: ALL OHVisits rows (active + dismissed) for admin history
        """
        q = OHVisits.query
        if not include_dismissed:
            q = q.filter(OHVisits.dismissed == 0)
        questions = q.order_by(desc(OHVisits.Sqid)).all()
        return questions

    def Get_active_OH_questions_for_project(self, project_id: int):
        """
        Student-safe queue: only active (dismissed == 0) for one project, FIFO order.
        """
        questions = (OHVisits.query
            .filter(and_(OHVisits.projectId == int(project_id), OHVisits.dismissed == 0))
            .order_by(OHVisits.Sqid.asc())
            .all())
        return questions

    def get_active_question(self, user_id, accepted_only: bool = False):
        """
        When accepted_only is False (default): any not-dismissed question counts as active
        (used by the Office Hours queue to persist 'in-queue' state).
        When True: only accepted questions (ruling == 1 AND TimeAccepted is not null) count as active
        (used by Upload page to show the banner only after acceptance).
        """
        base_query = OHVisits.query.filter(
            and_(OHVisits.StudentId == user_id, OHVisits.dismissed == 0)
        )
        if accepted_only:
            base_query = base_query.filter(
                and_(OHVisits.ruling == 1, OHVisits.TimeAccepted.isnot(None))
            )
        question = base_query.order_by(OHVisits.Sqid.desc()).first()
        if question is None:
            return -1
        return question.Sqid

    def get_accepted_oh_for_class(self, user_id, class_id):
        """
        Return Sqid of the most recent accepted (ruling==1, not dismissed, TimeAccepted set)
        OH entry for this user that belongs to the current project of the given class_id.
        If class_id is None or there is no current project match, fall back to any class.
        """
        # Base: accepted & not dismissed for this user
        q = OHVisits.query.filter(
            and_(OHVisits.StudentId == user_id,
                 OHVisits.dismissed == 0,
                 OHVisits.ruling == 1,
                 OHVisits.TimeAccepted.isnot(None))
        )
        # If a class_id is provided, scope to projects from that class
        if class_id is not None:
            q = (q.join(Projects, Projects.Id == OHVisits.projectId)
                   .filter(Projects.ClassId == class_id))
        result = q.order_by(OHVisits.Sqid.desc()).first()
        return result.Sqid if result else -1

    def check_timeout(self, user_id, project_id):
        tbs_settings = [5, 15, 45, 60, 90, 120, 120, 120]
        #get the two most recent submissions for a given projectID
        submissions = Submissions.query.filter(and_(Submissions.Project == project_id, Submissions.User == user_id)).order_by(desc(Submissions.Time)).first()
        #get the time of the most recent submission
        if submissions == None:
            return [1, "None"]
        most_recent_submission = submissions.Time
        project_start_date = Projects.query.filter(Projects.Id == project_id).first().Start
        #Get how many days have passed since the project start date
        days_passed = (datetime.now() - project_start_date).days
        if days_passed > 7:
            days_passed = 7
        # get current time
        current_time = datetime.now()
        #given the student ID and project, query to see if there was a question asked for this project, get the most recent question
        question = OHVisits.query.filter(and_(OHVisits.StudentId == user_id, OHVisits.projectId == project_id)).order_by(desc(OHVisits.TimeSubmitted)).first()
        time_until_resubmission=""
        tbs_threshold = tbs_settings[days_passed]
        if question == None:
            if most_recent_submission + timedelta(minutes=tbs_threshold) < current_time:
                return [1, "None"]
        time_until_resubmission = most_recent_submission + timedelta(minutes=tbs_threshold) - current_time
        if question is not None and question.ruling == 1:
            if question.dismissed == 0:
                return [1, "None"]
            submission_time_limit = question.TimeSubmitted + timedelta(hours=3)
            if submission_time_limit > current_time:
                if most_recent_submission + timedelta(minutes=tbs_threshold / 3) < current_time:
                    return [1, "None"]
                time_until_resubmission = most_recent_submission + timedelta(minutes=tbs_threshold / 3) - current_time
            else:
                if most_recent_submission + timedelta(minutes=tbs_threshold) < current_time:
                    return [1, "None"]
        return [0, time_until_resubmission]

    def check_visibility(self, user_id, project_id):
        # Get most recent submission given userId and projectID
        submission = Submissions.query.filter(and_(Submissions.User == user_id, Submissions.Project == project_id)).order_by(desc(Submissions.Time)).first()
        if submission == None:
            print("Error: No submission found", flush=True)
            return True
        return False
    
    def get_remaining_OH_Time(self, user_id, project_id):
        #Get the most recent question asked by the student for the given project that is dismissed
        question = OHVisits.query.filter(and_(OHVisits.StudentId == user_id, OHVisits.projectId == int(project_id), OHVisits.dismissed == 1)).order_by(desc(OHVisits.TimeSubmitted)).first()
        #Get how long until this time is the current time
        if question == None:
            return "Expired"
        elif question.TimeAccepted == None:
            formatted_time_remaining = f"{3} hours, {0} minutes" 
            return formatted_time_remaining 
        current_time = datetime.now()
        time_remaining = question.TimeCompleted + timedelta(hours=3) - current_time
        if time_remaining < timedelta(minutes=0):
            formatted_time_remaining = "Expired"
        else:
            hours = time_remaining.seconds // 3600
            minutes = (time_remaining.seconds % 3600) // 60
            formatted_time_remaining = f"{hours} hours, {minutes} minutes" 
        return formatted_time_remaining 
    
    def get_number_of_questions_asked(self, user_id, project_id):
        number_of_questions = OHVisits.query.filter(and_(OHVisits.StudentId == user_id, OHVisits.projectId == int(project_id))).count()
        return number_of_questions
    
    def get_student_questions_asked(self, user_id, project_id):
        questions = OHVisits.query.filter(and_(OHVisits.StudentId == user_id, OHVisits.projectId == int(project_id))).all()
        return questions
    
    def get_all_submissions_for_project(self, project_id):
        submissions = Submissions.query.filter(Submissions.Project == project_id).all()
        return submissions

    def get_all_submission_times(self, project_id):
        project = Projects.query.filter(Projects.Id == project_id).first()
        project_start_date = project.Start
        project_end_date = project.End

        blocks = [
            '12:00 AM - 2:00 AM',
            '2:00 AM - 4:00 AM',
            '4:00 AM - 6:00 AM',
            '6:00 AM - 8:00 AM',
            '8:00 AM - 10:00 AM',
            '10:00 AM - 12:00 PM',
            '12:00 PM - 2:00 PM',
            '2:00 PM - 4:00 PM',
            '4:00 PM - 6:00 PM',
            '6:00 PM - 8:00 PM',
            '8:00 PM - 10:00 PM',
            '10:00 PM - 12:00 AM'
        ]
        submissions_dict = {(project_start_date + timedelta(days=i)).strftime('%A %b %d'): {block: 0 for block in blocks} for i in range(8)}

        submissions = Submissions.query.filter(Submissions.Project == project_id).all()

        students ={}
        for submission in submissions:
            
            if submission.User not in students:
                if submission.IsPassing == 1:
                    students[submission.User] = -1
                else:
                    students[submission.User] = 1
            else:
                if submission.IsPassing == 1:
                    students[submission.User] = -1
                else:
                    if students[submission.User] != -1:
                        students[submission.User] += 1
            date = submission.Time.date()
            weekday_date = date.strftime('%A %b %d')
            hour = submission.Time.hour
            if (date < project_start_date.date()) or (date > (project_start_date.date() + timedelta(days=9))):
                continue

            if weekday_date not in submissions_dict:
                submissions_dict[weekday_date] = {block: 0 for block in blocks}

            block_index = hour // 2
            block = blocks[block_index]

            submissions_dict[weekday_date][block] += 1

        students = {student: value for student, value in students.items() if value != -1}
        students = dict(sorted(students.items(), key=lambda item: item[1], reverse=True)[:10])
        
        students_list = []
        for student_id in students:
            student = Users.query.filter(Users.Id == student_id).first()
            students_list.append([student_id,  students[student_id],student.Firstname, student.Lastname, student.Email])

        # Create a list of weekdays starting from start_weekday and ending on the day before start_weekday in the next week
        weekdays = []
        for i in range(9):
            date = project_start_date + timedelta(days=i)
            weekdays.append(date.strftime('%A %b %d'))
        submission_heatmap = []
        for weekday_date in weekdays:
            blocks = submissions_dict.get(weekday_date)
            if blocks:
                data = list(blocks.values())
                submission_heatmap.append({
                    'name': weekday_date,
                    'data': data
                })
            else:
                submission_heatmap.append({
                    'name': weekday_date,
                    'data': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
                })
        #reverse the list so that the days are in order
        submission_heatmap.reverse()

        return submission_heatmap, students_list
    
    def day_to_day_visualizer(self, project_id, user_ids):

        project = Projects.query.filter(Projects.Id == project_id).first()
        project_start_date = project.Start
        project_end_date = project.End

        dates = []
        date = project_start_date

        days_live = (project_end_date - project_start_date).days
        for i in range(days_live + 1):
            dates.append(date.strftime('%Y/%m/%d'))
            date += timedelta(days=1)
        

        passed =[0 for i in range(days_live + 1)]
        failed =[0 for i in range(days_live + 1)]
        no_submission =[0 for i in range(days_live + 1)]

        submissions = Submissions.query.filter(Submissions.Project == project_id).all()
        
        for user_Id in user_ids:
            passed_flag = False # flag to check if the user has passed the project for a given date
            submission_flag = False # flag to check if the user has submitted for a given date
            for date in dates:
                for submission in submissions:
                    if submission.Time.strftime('%Y/%m/%d') == date and submission.User == user_Id:
                        submission_flag = True
                        if submission.IsPassing:
                            passed_flag = True
                            break
                if not submission_flag:
                    no_submission[dates.index(date)] += 1
                else:
                    if passed_flag:
                        passed[dates.index(date)] += 1
                    else:
                        failed[dates.index(date)] += 1
    
        return dates, passed, failed, no_submission
    def get_all_submissions_for_user(self, user_id):
        submissions = Submissions.query.filter(Submissions.User == user_id).all()
        return submissions
    def get_project_scores(self, project_id):
        scores = StudentGrades.query.filter(StudentGrades.Pid == project_id).all()
        student_list = []
        for score in scores:
            student_list.append([score.Sid, score.Grade])
        return student_list
    def submitSuggestion(self, user_id, suggestion):
        dt_string = datetime.now().strftime("%Y/%m/%d %H:%M:%S")
        suggestion = StudentSuggestions(UserId=user_id, StudentSuggestionscol=suggestion, TimeSubmitted=dt_string)
        db.session.add(suggestion)
        db.session.commit()
        return "ok"
    def get_charges(self, user_id, class_id, project_id):
        tbs_settings = [5, 15, 45, 60, 90, 120, 120, 120]
        tbs_settings = [i * 3 for i in tbs_settings]
        project_start_date = Projects.query.filter(Projects.Id == project_id).first().Start
        charges = SubmissionCharges.query.filter(and_(SubmissionCharges.UserId == user_id, SubmissionCharges.ClassId == class_id)).first()
        if charges is None:
            charge = SubmissionCharges(UserId=user_id, ClassId=class_id, BaseCharge=3, RewardCharge=0)
            db.session.add(charge)
            db.session.commit()
            return [3, 0]
        try:
            charges = SubmissionCharges.query.filter(and_(SubmissionCharges.UserId == user_id, SubmissionCharges.ClassId == class_id)).first()

            # If base charges are not full, we use a SINGLE cooldown timer.
            # When the cooldown expires, ALL base charges refill to 3 at once.
            if charges.BaseCharge < 3:
                last_base = (SubmissionChargeRedeptions.query
                    .filter(and_(
                        SubmissionChargeRedeptions.UserId == int(user_id),
                        SubmissionChargeRedeptions.ClassId == int(class_id),
                        SubmissionChargeRedeptions.projectId == int(project_id),
                        SubmissionChargeRedeptions.Type == "base",
                        SubmissionChargeRedeptions.Recouped == 0
                    ))
                    .order_by(desc(SubmissionChargeRedeptions.RedeemedTime))
                    .first())

                if last_base is not None and last_base.RedeemedTime is not None:
                    charge_date = last_base.RedeemedTime
                    days_passed = (charge_date - project_start_date).days
                    days_passed = max(0, min(days_passed, len(tbs_settings) - 1))
                    tbs_threshold = tbs_settings[days_passed]

                    if datetime.now() >= last_base.RedeemedTime + timedelta(minutes=tbs_threshold):
                        # FULL recharge
                        charges.BaseCharge = 3
                        # Mark all un-recouped base redemptions for this project as handled
                        pending = (SubmissionChargeRedeptions.query
                            .filter(and_(
                                SubmissionChargeRedeptions.UserId == int(user_id),
                                SubmissionChargeRedeptions.ClassId == int(class_id),
                                SubmissionChargeRedeptions.projectId == int(project_id),
                                SubmissionChargeRedeptions.Type == "base",
                                SubmissionChargeRedeptions.Recouped == 0
                            ))
                            .all())
                        for r in pending:
                            r.Recouped = 1
                        db.session.commit()

            # If this is a new project (no base redemptions yet) and carryover left the student < 3,
            # reset to full base charges so each project starts fresh.
            current_proj_redemption = SubmissionChargeRedeptions.query.filter(
                and_(
                    SubmissionChargeRedeptions.UserId == int(user_id),
                    SubmissionChargeRedeptions.ClassId == int(class_id),
                    SubmissionChargeRedeptions.projectId == int(project_id),
                    SubmissionChargeRedeptions.Type == "base"
                )
            ).first()
            if charges.BaseCharge < 3 and current_proj_redemption is None:
                charges.BaseCharge = 3
                db.session.commit()

        except  Exception as e:
            return [0, 0]
        return [charges.BaseCharge, charges.RewardCharge]

    def get_time_until_recharge(self, user_id, class_id, project_id):
        project_start_date = Projects.query.filter(Projects.Id == project_id).first().Start
        #Get how many days have passed since the project start date
        tbs_settings = [5, 15, 45, 60, 90, 120, 120, 120]
        tbs_settings = [i * 3 for i in tbs_settings]
        charge_redemptions = SubmissionChargeRedeptions.query.filter(
            and_(
                SubmissionChargeRedeptions.UserId == user_id, 
                SubmissionChargeRedeptions.ClassId == class_id, 
                SubmissionChargeRedeptions.projectId == project_id, 
                SubmissionChargeRedeptions.Recouped == 0,
                SubmissionChargeRedeptions.Type=="base"
            )
        ).order_by(desc(SubmissionChargeRedeptions.RedeemedTime)).first()
        #Idenify on what date the charge was redeemed

        if charge_redemptions is None:
            # No redemption in this project yet â†’ nothing to count down from
            return timedelta(seconds=0)
        charge_date = charge_redemptions.RedeemedTime

        #Identify how many days have passed since the project start date
        days_passed = (charge_date - project_start_date).days
        if days_passed > 7:
            days_passed = 7
        #Get the TBS threshold for the given day
        tbs_threshold = tbs_settings[days_passed]
         
        # Get the time until the next recharge
        time_until_resubmission = charge_redemptions.RedeemedTime + timedelta(minutes=tbs_threshold) - datetime.now()
        if time_until_resubmission.total_seconds() < 0:
            return timedelta(seconds=0)

        return time_until_resubmission
  
    def consume_charge(self, user_id, class_id, project_id, submission_id):
        dt_string = datetime.now().strftime("%Y/%m/%d %H:%M:%S")

        # Ensure a SubmissionCharges row exists for this user/class.
        charge = SubmissionCharges.query.filter(
            and_(SubmissionCharges.UserId == user_id, SubmissionCharges.ClassId == class_id)
        ).first()
        if charge is None:
            charge = SubmissionCharges(UserId=user_id, ClassId=class_id, BaseCharge=3, RewardCharge=0)
            db.session.add(charge)
            db.session.commit()

        submission_charge = None

        # Determine if a user is in an active office hour session; if so, do not charge the student.
        question = OHVisits.query.filter(
            and_(OHVisits.StudentId == user_id, OHVisits.dismissed == 0)
        ).first()
        print("Question is: ", question, flush=True)

        if question is not None and question.ruling == 1:
            submission = Submissions.query.filter(Submissions.Id == submission_id).first()
            db.session.commit()
            return "ok"

        # Determine if a user has an unredeemed reward charge for the given project.
        reward_charge = SubmissionChargeRedeptions.query.filter(
            and_(
                SubmissionChargeRedeptions.UserId == user_id,
                SubmissionChargeRedeptions.ClassId == class_id,
                SubmissionChargeRedeptions.projectId == project_id,
                SubmissionChargeRedeptions.Type == "reward",
            )
        ).all()
        if len(reward_charge) > 0:
            for reward in reward_charge:
                if reward.RedeemedTime is None:
                    if charge.RewardCharge > 0:
                        charge.RewardCharge -= 1
                        db.session.commit()
                    reward.RedeemedTime = dt_string
                    reward.submissionId = submission_id
                    reward.Recouped = 1
                    db.session.commit()
                    submission = Submissions.query.filter(Submissions.Id == submission_id).first()
                    db.session.commit()
                    return "ok"

        # Consume a base charge if available.
        if charge and charge.BaseCharge > 0:
            charge.BaseCharge -= 1
            submission_charge = SubmissionChargeRedeptions(
                UserId=user_id,
                ClassId=class_id,
                projectId=project_id,
                Type="base",
                ClaimedTime=dt_string,
                RedeemedTime=dt_string,
                SubmissionId=submission_id,
                Recouped=0,
            )
            db.session.add(submission_charge)
            db.session.commit()

        # Update the visibility of the submission
        submission = Submissions.query.filter(Submissions.Id == submission_id).first()
        db.session.commit()
        return "ok"

    def Charge_use_accounting(self, submission_id, charge_id):
        dt_string = datetime.now().strftime("%Y/%m/%d %H:%M:%S")
        charge = SubmissionChargeRedeptions.query.filter(SubmissionChargeRedeptions.Id == charge_id).first()
        charge.submissionId = submission_id
        charge.RedeemedTime = dt_string
        db.session.commit()
        return "ok"
    def add_reward_charge(self, user_id, class_id, rewardAmount):
        charge = SubmissionCharges.query.filter(and_(SubmissionCharges.UserId == user_id, SubmissionCharges.ClassId == class_id)).first()
        charge.RewardCharge += rewardAmount
        if charge.RewardCharge > 5:
            charge.RewardCharge = 5
        db.session.commit()
    def consume_reward_charge(self, user_id, class_id, project):
        dt_string = datetime.now().strftime("%Y/%m/%d %H:%M:%S")
        try:
            student_submissionCharges = SubmissionCharges.query.filter(and_(SubmissionCharges.UserId == user_id, SubmissionCharges.ClassId == class_id)).first()
            if student_submissionCharges.RewardCharge < 1:
                return 0
            # Reserve a FastPass without consuming it yet (pending until next submission)
            reward_charge = SubmissionChargeRedeptions(
                UserId=user_id,
                ClassId=class_id,
                projectId=project,
                Type="reward",
                ClaimedTime=dt_string,
                Recouped=0
            )
            db.session.add(reward_charge)
            db.session.commit()
            
            return 1
        except Exception as e:
            print("An error occurred while handling the database operation", e)
            db.session.rollback()
            return 0

    def save_manual_grading(self, submission_id, grade, errors):
        try:
            # update grade in StudentGrades table
            sub = Submissions.query.get(submission_id) 
            
            sid = sub.User #student ID
            pid = sub.Project # project ID

            grades = StudentGrades.query.filter(StudentGrades.Sid == sid).filter(StudentGrades.Pid == pid).first()
            if grades:
                grades.Grade = grade
            else:
                #add new grade entry if none exists
                new_grade = StudentGrades(
                    Sid=sid,
                    Pid=pid,
                    Grade=grade
                )
                db.session.add(new_grade)
            
            # delete existing errors
            SubmissionManualErrors.query.filter_by(SubmissionId=submission_id).delete()

            # add new errors
            for error in errors:
                new_err = SubmissionManualErrors(
                    SubmissionId=submission_id,
                    LineNumber=error['line'],
                    ErrorId=error['errorId']
                )
                db.session.add(new_err)

            db.session.commit()
            return True
        except Exception as e:
            db.session.rollback()
            return False
            
    def get_manual_errors(self, submission_id):
        
        # fetch all errors for this submission
        errors = SubmissionManualErrors.query.filter(SubmissionManualErrors.SubmissionId == submission_id).all()
        
        # convert to list of dicts
        return [
            {'line': e.LineNumber, 'errorId': e.ErrorId} 
            for e in errors
        ]